var documenterSearchIndex = {"docs":
[{"location":"parametric/#Parametric-Curve-Interpolation","page":"Parametric Curve","title":"Parametric Curve Interpolation","text":"","category":"section"},{"location":"parametric/","page":"Parametric Curve","title":"Parametric Curve","text":"It is sometimes useful to interpolate a set of points in n dimensions that lie on a one-dimensional curve, a parametric curve. The curve is like the trajectory of a point moving through space. To accomplish this, one option is to interpolate each dimension of coordinates independently using the distance between the points as the independent variable. The ParametricCurveInterpolator does this using natural cubic splines. It's constructed from arrays representing the coordinates in each dimension, then interpolated with a normalized coordinate in [0,1]. For example, to interpolate the curve in 3D space represented by","category":"page"},{"location":"parametric/","page":"Parametric Curve","title":"Parametric Curve","text":"beginaligned\nx(t) = tsin(t) \ny(t) = exp(t2) \nz(t) = t^3\nendaligned","category":"page"},{"location":"parametric/","page":"Parametric Curve","title":"Parametric Curve","text":"over t  -22 with 25 points, we would do the following","category":"page"},{"location":"parametric/","page":"Parametric Curve","title":"Parametric Curve","text":"using BasicInterpolators: ParametricCurveInterpolator\nt = collect(LinRange(-2, 2, 25));\nx = t.*sin.(t);\ny = exp.(t/2);\nz = t.^3;\nP = ParametricCurveInterpolator(x, y, z);","category":"page"},{"location":"parametric/","page":"Parametric Curve","title":"Parametric Curve","text":"Then P can be called like a function on any coordinate in [0,1] to draw a smooth curve through the points. Of course, you wouldn't need to interpolate these points if you knew the underlying function, but it's an example.","category":"page"},{"location":"parametric/","page":"Parametric Curve","title":"Parametric Curve","text":"Like the other interpolators, extrapolation will cause an error by default. To override the boundary check, pass false after the interpolation coordinate, as in P(0.1, false). Each underlying spline will then extrapolate. As always, you're likely to get wild results when extrapolating far from the boundaries.","category":"page"},{"location":"parametric/","page":"Parametric Curve","title":"Parametric Curve","text":"","category":"page"},{"location":"parametric/","page":"Parametric Curve","title":"Parametric Curve","text":"ParametricCurveInterpolator","category":"page"},{"location":"parametric/#BasicInterpolators.ParametricCurveInterpolator","page":"Parametric Curve","title":"BasicInterpolators.ParametricCurveInterpolator","text":"ParametricCurveInterpolator(V...)\n\nConstruct an interpolator for a set of points in arbitrary dimensions that defines a one-dimensional curve, using natural cubic splines in each dimension.\n\n\n\n\n\n","category":"type"},{"location":"1d/#One-dimensional-Interpolation","page":"One Dimension","title":"One-dimensional Interpolation","text":"","category":"section"},{"location":"1d/","page":"One Dimension","title":"One Dimension","text":"","category":"page"},{"location":"1d/","page":"One Dimension","title":"One Dimension","text":"Interpolators Method\nLinearInterpolator piecewise linear\nCubicInterpolator piecewise cubic (no smoothness guarantee)\nCubicSplineInterpolator cubic spline, natural or clamped\nChebyshevInterpolator Chebyshev expansion","category":"page"},{"location":"1d/","page":"One Dimension","title":"One Dimension","text":"","category":"page"},{"location":"1d/","page":"One Dimension","title":"One Dimension","text":"Functions Use\nquadratic quadratic interpolation of any 3 points\ncubic cubic interpolation of any 4 points\nneville (n-1)th order polynomial interpolation of any n points\nvandermonde coefficients of (n-1)th order polynomial passing through n points\ncubichermite cubic interpolation using two points with first derivatives","category":"page"},{"location":"1d/","page":"One Dimension","title":"One Dimension","text":"","category":"page"},{"location":"1d/","page":"One Dimension","title":"One Dimension","text":"LinearInterpolator\nCubicInterpolator\nCubicSplineInterpolator\nChebyshevInterpolator\nquadratic\ncubic\nneville\nvandermonde\ncubichermite","category":"page"},{"location":"1d/#BasicInterpolators.LinearInterpolator","page":"One Dimension","title":"BasicInterpolators.LinearInterpolator","text":"LinearInterpolator(x, y)\n\nConstruct a LinearInterpolator for the points defined by coordinates x and values y\n\n\n\n\n\nLinearInterpolator(f, xa, xb, n)\n\nConstruct a LinearInterpolator for the function f using n evenly spaced function evaluations in the range [xa,xb]\n\n\n\n\n\n","category":"type"},{"location":"1d/#BasicInterpolators.CubicInterpolator","page":"One Dimension","title":"BasicInterpolators.CubicInterpolator","text":"CubicInterpolator(x, y)\n\nConstruct a CubicInterpolator for the points defined by coordinates x and values y\n\n\n\n\n\nCubicInterpolator(f, xa, xb, n)\n\nConstruct a CubicInterpolator for the function f using n evenly spaced function evaluations in the range [xa,xb]\n\n\n\n\n\n","category":"type"},{"location":"1d/#BasicInterpolators.CubicSplineInterpolator","page":"One Dimension","title":"BasicInterpolators.CubicSplineInterpolator","text":"CubicSplineInterpolator(x, y)\n\nConstruct a CubicSplineInterpolator for the points defined by coordinates x and values y. This constructor creates a natural spline, where the second derivative is set to zero at the boundaries.\n\n\n\n\n\nCubicSplineInterpolator(x, y, dy‚ÇÅ, dy‚Çô)\n\nConstruct a CubicSplineInterpolator for the points defined by coordinates x and values y. This constructor creates a clamped spline, where the first derivatives at the boundaries are set by dy‚ÇÅ and dy‚Çô.\n\n\n\n\n\nCubicSplineInterpolator(f, xa, xb, n)\n\nConstruct a CubicSplineInterpolator for the function f using n evenly spaced function evaluations in the range [xa,xb]. A natural spline is created.\n\n\n\n\n\n","category":"type"},{"location":"1d/#BasicInterpolators.ChebyshevInterpolator","page":"One Dimension","title":"BasicInterpolators.ChebyshevInterpolator","text":"ChebyshevInterpolator(x, y)\n\nConstruct a ChebyshevInterpolator for the points defined by coordinates x and values y. The x coordinates must be arranged on a chebyshev grid, which can be generated using the chebygrid function.\n\nwarning: Warning\nThe Chebyshev interpolator is not thread-safe. It computes a cosine expansion in-place using an array stored with the object. A single ChebyshevInterpolator should never be called by multiple threads at once.\n\n\n\n\n\nChebyshevInterpolator(f, xa, xb, n)\n\nConstruct a ChebyshevInterpolator for the function f using n function evaluations in the range [xa,xb]. The function evaluations will occur on the chebyshev nodes.\n\n\n\n\n\n","category":"type"},{"location":"1d/#BasicInterpolators.quadratic","page":"One Dimension","title":"BasicInterpolators.quadratic","text":"quadratic(x, xp, yp)\n\nPerform quadratic polynomial interpolation of the points defined by coordinates xp and values yp, at the coordinate x, using Neville's algorithm. xp and yp must both contain three points.\n\n\n\n\n\n","category":"function"},{"location":"1d/#BasicInterpolators.cubic","page":"One Dimension","title":"BasicInterpolators.cubic","text":"cubic(x, xp, yp)\n\nPerform cubic polynomial interpolation of the points defined by coordinates xp and values yp, at the coordinate x, using Neville's algorithm. xp and yp must both contain four points.\n\n\n\n\n\n","category":"function"},{"location":"1d/#BasicInterpolators.neville","page":"One Dimension","title":"BasicInterpolators.neville","text":"neville(x, xp, yp)\n\nPerform polynomial interpolation of the points defined by coordinates xp and values yp, at the coordinate x, using Neville's algorithm with as many points as are provided. xp and yp must have the same length. With only 3 or 4 points the quadratic and cubic functions will be faster.\n\n\n\n\n\n","category":"function"},{"location":"1d/#BasicInterpolators.vandermonde","page":"One Dimension","title":"BasicInterpolators.vandermonde","text":"vandermonde(x, y)\n\nGenerate the coefficients of an arbitrary order polynomial passing through the ponts defined by coordinates x and value y. For n points, n coefficients c_0 c_1  c_n-1 are returned forming the polynomial c_0 + c_1x +  + c_n-1x^n-1\n\nwarning: Warning\nSolving for the the coefficients of a high-order polynomial is a notoriously ill-conditioned problem. It is not recommended for orders greater than 5 or 6, although it depends on the application. If you must interpolate with a high-order polynomial, it's better to use the neville function instead of computing coefficients.\n\n\n\n\n\n","category":"function"},{"location":"1d/#BasicInterpolators.cubichermite","page":"One Dimension","title":"BasicInterpolators.cubichermite","text":"cubichermite(x, xa, xb, ya, yb, dya, dyb)\n\nInterpolate a cubic polynomial between two points, given its values and first derivatives at the points.\n\n\n\n\n\n","category":"function"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Pieces of the package that might be useful ü§∑","category":"page"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"findcell\nchebygrid","category":"page"},{"location":"misc/#BasicInterpolators.findcell","page":"Miscellaneous","title":"BasicInterpolators.findcell","text":"findcell(q, V)\n\nUse bisection search to find the cell containing q, assuming V is a sorted vector of coordinates. The returned integer is the index of the element in V immediately less than q. For example, if findcell returns 2, then q ‚àà [V[2],V[3]). If q is less than every element in V, 1 is returned, indicating the first cell in V. If q is greater than every element in V, length(V)-1 is returned, indicating the last cell in V.\n\n\n\n\n\n","category":"function"},{"location":"misc/#BasicInterpolators.chebygrid","page":"Miscellaneous","title":"BasicInterpolators.chebygrid","text":"chebygrid(n)\n\nCreate an array of n chebyshev nodes in [-1,1]\n\n\n\n\n\nchebygrid(xa, xb, n)\n\nCreate an array of n chebyshev nodes in [xa,xb]\n\n\n\n\n\nchebygrid(xa, xb, nx, ya, yb, ny)\n\nCreate a two-dimensional grid of chebyshev nodes using nx points along the first axis, in [xa,xb], and ny points along the second axis, in [ya,yb].\n\n\n\n\n\n","category":"function"},{"location":"chebyshev/#Chebyshev-Interpolation","page":"Chebyshev Interpolation","title":"Chebyshev Interpolation","text":"","category":"section"},{"location":"chebyshev/","page":"Chebyshev Interpolation","title":"Chebyshev Interpolation","text":"Chebyshev interpolation is an extremely accurate method for interpolating smooth functions. It's a good way to replace a very slow/costly function with a high accuracy approximation (if the function is smooth!). The extremely high accuracy is achieved by careful placement of the interpolation nodes at the Chebyshev nodes. This part of BasicInterpolators that is not really so basic, but chebyshev interpolation is a powerful tool in the right context and it's worth providing easy access to it.","category":"page"},{"location":"chebyshev/","page":"Chebyshev Interpolation","title":"Chebyshev Interpolation","text":"To easily create a ChebyshevInterpolator or BichebyshevInterpolator without dealing with the specific grid spacing they require, pass a function to the constructor. The function will be evaluated at the appropriate locations to generate an interpolating approximation. For example, for two-dimensional interpolation of f(xy) = sin(x) + cos(y) with xy  -33","category":"page"},{"location":"chebyshev/","page":"Chebyshev Interpolation","title":"Chebyshev Interpolation","text":"using BasicInterpolators: BichebyshevInterpolator\nf(x,y) = sin(x) + cos(y)\nP = BichebyshevInterpolator(f, -3, 3, 16, -3, 3, 16);\nP(1, 2) - f(1, 2)","category":"page"},{"location":"chebyshev/","page":"Chebyshev Interpolation","title":"Chebyshev Interpolation","text":"With 16 points in each dimension, the error is already about one part per trillion. This is a contrived example and the incredible accuracy of Chebyshev interpolation can be demonstrated more thoroughly, but the important fact is that Chebyshev approximations to smooth functions have exponential, or \"infinite order\" convergence. As soon as there are enough points for the Chebyshev approximation to capture the function's basic shape, the error will plummet to machine precision as more points are added. For more on this and related topics, I recommend the following book","category":"page"},{"location":"chebyshev/","page":"Chebyshev Interpolation","title":"Chebyshev Interpolation","text":"Boyd, John P. Chebyshev and Fourier spectral methods. Courier Corporation, 2001.","category":"page"},{"location":"chebyshev/","page":"Chebyshev Interpolation","title":"Chebyshev Interpolation","text":"The Chebyshev interpolators do some things in the background that the other interpolators don't. Construction requires some matrix math, but constructing many interpolators with the same dimensions will be fast because the inverted matrices are cached. Evaluation avoids as many direct cos evaluations as possible and uses fast in-place linear algebra functions where appropriate (mul!). Because of the in-place operations, a single interpolator is not thread-safe. But, the speed of the Chebyshev interpolators here should compare well with any other implementations and they should be easy to use.","category":"page"},{"location":"2d/#Two-dimensional-Interpolation","page":"Two Dimensions","title":"Two-dimensional Interpolation","text":"","category":"section"},{"location":"2d/","page":"Two Dimensions","title":"Two Dimensions","text":"The following interpolator types all operate on regular grids.","category":"page"},{"location":"2d/","page":"Two Dimensions","title":"Two Dimensions","text":"The BilinearInterpolator and BicubicInterpolator will work with any regular, unevenly spaced grids.\nThe BicubicSplineInterpolator expects uniform spacing in each dimension, although the spacing on one axis doesn't have to match the other. This interpolator estimates derivatives using finite differences to construct the splines.\nThe BichebyshevInterpolator must have the usual Chebyshev spacing in each direction, but it can have a different number of points on each axis.","category":"page"},{"location":"2d/","page":"Two Dimensions","title":"Two Dimensions","text":"","category":"page"},{"location":"2d/","page":"Two Dimensions","title":"Two Dimensions","text":"Interpolators Method\nBilinearInterpolator piecewise linear\nBicubicInterpolator piecewise cubic (no smoothness guarantee)\nBicubicSplineInterpolator cubic spline using approximate derivatives (smooth)\nBichebyshevInterpolator Chebyshev expansions","category":"page"},{"location":"2d/","page":"Two Dimensions","title":"Two Dimensions","text":"","category":"page"},{"location":"2d/","page":"Two Dimensions","title":"Two Dimensions","text":"BilinearInterpolator\nBicubicInterpolator\nBicubicSplineInterpolator\nBichebyshevInterpolator","category":"page"},{"location":"2d/#BasicInterpolators.BilinearInterpolator","page":"Two Dimensions","title":"BasicInterpolators.BilinearInterpolator","text":"BilinearInterpolator(x, y, Z)\n\nConstruct a BilinearInterpolator for the grid of points points defined by coordinates x,y and values Z.\n\n\n\n\n\nBilinearInterpolator(f, xa, xb, nx, ya, yb, ny)\n\nConstruct a BilinearInterpolator for the function f using a grid of nx points evenly spaced on the first axis in [xa,xb] and ny points evenly spaced on the second axis in [ya,yb].\n\n\n\n\n\n","category":"type"},{"location":"2d/#BasicInterpolators.BicubicInterpolator","page":"Two Dimensions","title":"BasicInterpolators.BicubicInterpolator","text":"BicubicInterpolator(x, y, Z)\n\nConstruct a BicubicInterpolator for the grid of points points defined by coordinates x,y and values Z.\n\n\n\n\n\nBicubicInterpolator(f, xa, xb, nx, ya, yb, ny)\n\nConstruct a BicubicInterpolator for the function f using a grid of nx points evenly spaced on the first axis in [xa,xb] and ny points evenly spaced on the second axis in [ya,yb].\n\n\n\n\n\n","category":"type"},{"location":"2d/#BasicInterpolators.BicubicSplineInterpolator","page":"Two Dimensions","title":"BasicInterpolators.BicubicSplineInterpolator","text":"BicubicSplineInterpolator(x, y, Z)\n\nConstruct a BicubicSplineInterpolator for the grid of points points defined by coordinates x,y and values Z.\n\n\n\n\n\nBicubicSplineInterpolator(f, xa, xb, nx, ya, yb, ny)\n\nConstruct a BicubicSplineInterpolator for the function f using a grid of nx points evenly spaced on the first axis in [xa,xb] and ny points evenly spaced on the second axis in [ya,yb].\n\n\n\n\n\n","category":"type"},{"location":"2d/#BasicInterpolators.BichebyshevInterpolator","page":"Two Dimensions","title":"BasicInterpolators.BichebyshevInterpolator","text":"BichebyshevInterpolator(x, y, Z)\n\nConstruct a BichebyshevInterpolator for the grid of points defined by coordinates (x,y) and values Z. The given points must lie on a chebyshev grid in each direction. These can be generated with the chebygrid function or the interpolator can be constructed directly from a function using the method below.\n\nwarning: Warning\nThe Bichebyshev interpolator is not thread-safe. It computes a cosine expansion and does some linear algebra in-place using arrays stored with the object. A single BichebyshevInterpolator should never be called by multiple threads at once.\n\n\n\n\n\nBichebyshevInterpolator(f, xa, xb, nx, ya, yb, ny)\n\nConstruct a BichebyshevInterpolator for the function f using a grid of nx points on the first axis in [xa,xb] and ny points on the second axis in [ya,yb].\n\n\n\n\n\n","category":"type"},{"location":"#BasicInterpolators.jl","page":"Home","title":"BasicInterpolators.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the BasicInterpolators documentation. This package provides a collection of common interpolation recipes. Quick facts about the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"All types and functions assume the use of real numbers and will return double precision (Float64) numbers.\nThe Interpolator types are the main focus. To use them, you construct an interpolator object then call it like a function. There are also some functions for things like one-off polynomial interpolation.\nThere are two-dimensional grid interpolators, but not higher.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Details","page":"Home","title":"Details","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For a tutorial, see the \"how to\" section below. For more information on the specific types and methods available, see these links:","category":"page"},{"location":"","page":"Home","title":"Home","text":"One-dimensional interpolation\nTwo-dimensional interpolation\nN-dimensional, scattered point interpolation\nParametric Curve Interpolation","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a little extra on the Chebyshev interpolators, look here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Other-Packages","page":"Home","title":"Other Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you need more features/methods, please look in other packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interpolations.jl\nDierckx.jl\nGridInterpolations.jl\nApproXD","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#How-to-Start-Interpolating-Stuff","page":"Home","title":"How to Start Interpolating Stuff","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BasicInterpolators offers callable types, or function-like objects, for your interpolation needs. This simply means that you construct an Interpolator object, like a LinearInterpolator or a BicubicInterpolator, then call it like a function, passing it the coordinate where you'd like to interpolate.","category":"page"},{"location":"#Construct-from-points","page":"Home","title":"Construct from points","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For example, to do linear interpolation on a range of three points, we construct a LinearInterpolator then call it on the interpolation coordinate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BasicInterpolators: LinearInterpolator\nx = [0, 1, 2];\ny = [0, 0.5, 1];\np = LinearInterpolator(x, y);\np(0.5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pretty basic! A nice result of this syntax is easy broadcasting. To interpolate a bunch of values in some array x, simply use p.(x).","category":"page"},{"location":"#Construct-from-a-function","page":"Home","title":"Construct from a function","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each of the types can be constructed by passing vectors/arrays with the points to interpolate. They can also be constructed with a function to sample from. This is most useful for the Chebyshev interpolators, which require a specific grid spacing. For example, to generate a ChebyshevInterpolator of the function f(x) = sin(2x) + x^2exp(x), in the range -30, using 16 points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BasicInterpolators: ChebyshevInterpolator\nf(x) = sin(2x) + x^2*exp(x);\np = ChebyshevInterpolator(f, -3, 0, 16);\nf(-1.5)\np(-1.5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the background, the constructor generates 16 points between -3 and 0, evaluates the function at those points, then sets up everything it needs to interpolate in that range.","category":"page"},{"location":"#Two-dimensional-interpolation","page":"Home","title":"Two-dimensional interpolation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The two-dimensional interpolators work the same way, but with another dimension (of course). You can supply the coordinates along each axis and a grid of points or you can supply a function along with where to evaluate it and how many points to use. For example, to make a BilinearInterpolator for a 10 by 10 grid of randomly spaced points with random values:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BasicInterpolators: BilinearInterpolator\nx = sort(rand(10));\ny = sort(rand(10));\nA = rand(10,10);\nP = BilinearInterpolator(x, y, A);\nP(0.5, 0.5)","category":"page"},{"location":"#Grid-spacing","page":"Home","title":"Grid spacing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Unevenly spaced grids are acceptable for all interpolators except the chebyshev interpolators and the bivariate spline, but you have to supply the coordinates directly instead of constructing with a function. When you do construct with a function, all the interpolators use evenly spaced points except for the chebyshev interpolators.","category":"page"},{"location":"#Boundaries","page":"Home","title":"Boundaries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The chebyshev interpolators won't let you extrapolate, or pass a point outside the stated interpolation range, because they are undefined outside the boundaries. All the other ones will let you extrapolate if you turn off the boundary check, which is an optional argument whenever you call an interpolator. For example,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BasicInterpolators: CubicSplineInterpolator\nx = [0, 1, 2];\ny = rand(3);\np = CubicSplineInterpolator(x, y);\n#trying to extrapolate will normally cause an error\np(-1)\n#but you can override the boundary check by passing `false`\np(-1, false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Extrapolation blindly uses the interpolating curve/surface of the nearest boundary cell in the grid, so it can easily return wild values, especially for the cubic interpolators. That's why it's not allowed by default. The same goes for two-dimensional interpolators. You can turn off the boundary check by passing false after the interpolation coordinates, as in P(x, y, false). In these cases, the false argument means \"don't check the boundaries.\"","category":"page"},{"location":"scattered/#Interpolation-of-Scattered-Points-in-N-Dimensions","page":"Scattered, N Dimensions","title":"Interpolation of Scattered Points in N Dimensions","text":"","category":"section"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"BasicInterpolators implements two types for interpolating scattered points in any number of dimensions.","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"radial basis function (RBF) interpolation using any radial basis function in the form œï(rœµ), where r is the distance between points and œµ is a scaling factor that can be used in any way. Several common functions are provided, but using your own function will not slow down the interpolator unless the function itself is slow. Constructing an RBF interpolator for p points requires the solution of a symmetric p  p matrix equation, which will require a noticeable amount of time and memory with a lot of points. Three common radial basis functions are available for convenience:\ninvmultiquadratic (default)\nmultiquadratic\ngaussian\nShepard interpolation, which is a special case of RBF interpolation where the radial basis function is œï(r) = r^-a, where r is the distance between points and a is a user-specified exponent. Shepard interpolation is usually less accurate than RBF interpolation, but it requires negligible construction time and memory.","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"For p points in N dimensions, construct these two interpolators with a pN array of coordinates and a length p vector of values to interpolate. For example, constructing an RBFInterpolator for 100 random points in three dimensions (with œµ=1) then interpolating at a point would look like","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"using BasicInterpolators: RBFInterpolator\nX = rand(100,3);\ny = rand(100);\nP = RBFInterpolator(X, y, 1);\nP(0.5, 0.5, 0.5)","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"The invmultiquadratic RBF is used here by default. To use any other RBF, pass a function in the form œï(rœµ) to the constructor after the scale factor, like P = RBFInterpolator(X, y, 1, myrbf).","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"The interpolators can be called with an array of coordinates, like P([1,2,3]), or with individual coordinates, like P(1,2,3). Either way is fine.","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"There is no perfect rule for choosing the scale factor, œµ. For the functions provided here, it should generally be larger than the spacing between points but smaller than variations in the interpolated points. For example, if you were interpolating the function f(xy) = sin(x) + sin(y), you might choose œµ1 because that's a little smaller than the width of the bumps in a sine curve. The best results may require some tinkering.","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"RBFInterpolator\ninvmultiquadratic\nmultiquadratic\ngaussian","category":"page"},{"location":"scattered/#BasicInterpolators.RBFInterpolator","page":"Scattered, N Dimensions","title":"BasicInterpolators.RBFInterpolator","text":"RBFInterpolator(X, y, œµ, rbf=invmultiquadratic)\n\nConstruct a radial basis function (RBF) interpolator for an n-dimensional set of points with coordinates X and values y. X must be an p √ó N array, where p is the number of points and N is the number of dimensions. y must be a length p vector. The value of œµ scales the radial basis function of choice, f, which is invmultiquadratic by default. Any function in the form œï(rœµ) can be passed to the rbf argument, where r is the distance between points and œµ is a scaling factor.\n\n\n\n\n\n","category":"type"},{"location":"scattered/#BasicInterpolators.invmultiquadratic","page":"Scattered, N Dimensions","title":"BasicInterpolators.invmultiquadratic","text":"invmultiquadratic(r, œµ)\n\nfrac1sqrt1 + (rœµ)^2\n\n\n\n\n\n","category":"function"},{"location":"scattered/#BasicInterpolators.multiquadratic","page":"Scattered, N Dimensions","title":"BasicInterpolators.multiquadratic","text":"multiquadratic(r, œµ)\n\nsqrt1 + (rœµ)^2\n\n\n\n\n\n","category":"function"},{"location":"scattered/#BasicInterpolators.gaussian","page":"Scattered, N Dimensions","title":"BasicInterpolators.gaussian","text":"gaussian(r, œµ)\n\ne^-r^2œµ^2\n\n\n\n\n\n","category":"function"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"","category":"page"},{"location":"scattered/","page":"Scattered, N Dimensions","title":"Scattered, N Dimensions","text":"ShepardInterpolator","category":"page"},{"location":"scattered/#BasicInterpolators.ShepardInterpolator","page":"Scattered, N Dimensions","title":"BasicInterpolators.ShepardInterpolator","text":"ShepardInterpolator(X, y, a=3)\n\nConstruct a ShepardInterpolator for an n-dimensional set of points with coordinates X and values y. X must be an p √ó N array, where p is the number of points and N is the number of dimensions. y must be a length p vector. The value of a defines the distance weighting function r^-a.\n\n\n\n\n\n","category":"type"}]
}
